
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((c7 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(c7 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 256) {
        for (c7, 0, 128) {
          buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] + (buf00[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))]*buf01[(c7 + int32((int64(c1)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 256) {
          buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c7)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c7)*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c7)*(int64)32768)))]*buf01[(c1 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 256) {
        for (c7, 0, 128) {
          buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c7 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c7 + int32((int64(c3)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 128) {
        for (c7, 0, 256) {
          buf03[((c5 + int32((int64(c7)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c7)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(c7)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(c5)*(int64)128)))]))
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          buf03[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c7 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c5 + int32((int64(c7)*(int64)128)))]))
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*4) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*4) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*8) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*8) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*16) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*16) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(c13 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((c11 + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(c11 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*4) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*4) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*8) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*8) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((c5 + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((c7*16) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((c7*16) + c9) + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c1)*(int64)128))) + int32((int64(c3)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i01_inner < 32 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i01_inner < 32 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 8 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i01_inner < 32 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*32) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01 < 256 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i01_inner < 64 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i01_inner < 64 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 4 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i01_inner < 64 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*64) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*64) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 4 | 0
		for 0 <= i01_inner < 128 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*64) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i01_inner < 128 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*32) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i01_inner < 128 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c1*128) + c5))*(int64)128))) + int32((int64(((c3*128) + c7))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*128) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i01_outer < 2 | 0
	for 0 <= i00_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c1*128) + c7))*(int64)128))) + int32((int64(((c3*32) + c9))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01 < 256 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*32) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*64) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*32) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*64) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*32) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c11 + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*64) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(c13 + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*32) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*32) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*32) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 64) {
                buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*64) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*64) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c11 + int32((int64(((c3*64) + c7))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 64) {
                buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(c3)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(c3)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(c3)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(c3)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(c3)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(c3)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01 < 256 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 256) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*4) + c9) + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*4) + c9) + int32((int64(c3)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 256) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*8) + c9) + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*8) + c9) + int32((int64(c3)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 256) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c7*16) + c9) + int32((int64(c5)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c7*16) + c9) + int32((int64(c3)*(int64)128)))]))
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(((c5*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(((c5*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i02 < 128 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c3 + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(((c5*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 8 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*32) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*32) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*64) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 2 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c3*64) + c7) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(c9)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i02_outer < 4 | 0
		for 0 <= i01_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c3*32) + c9) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c5*128) + c11))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00 < 256 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(c11 + int32((int64(((c1*32) + c5))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(c11 + int32((int64(((c1*32) + c5))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(c11 + int32((int64(((c1*32) + c5))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*32) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(c11 + int32((int64(((c1*64) + c5))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(c11 + int32((int64(((c1*64) + c5))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 128) {
              buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(c11 + int32((int64(((c1*64) + c5))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 128) {
                buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(c13 + int32((int64(((c1*64) + c7))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(c11 + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c7*32) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 64) {
                buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c7*64) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c7*32) + c11) + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c7*64) + c11) + int32((int64(c1)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00 < 256 | 0
			for 0 <= i03 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 256) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] + (buf00[((((c7*4) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))]*buf01[(((c7*4) + c9) + int32((int64(c1)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 256) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] + (buf00[((((c7*8) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))]*buf01[(((c7*8) + c9) + int32((int64(c1)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 256) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))] + (buf00[((((c7*16) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c5)*(int64)32768)))]*buf01[(((c7*16) + c9) + int32((int64(c1)*(int64)128)))]))
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((((c7*16) + c11)*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c11)*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c11)*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*16) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*32) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*64) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*8) + c13)*4) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*4) + c13)*8) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((((c7*2) + c13)*16) + c15) + int32((int64(c1)*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i03_outer < 4 | 0
				for 0 <= i00_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((((c7*8) + c11)*4) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((((c7*4) + c11)*8) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] = (buf03[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))] + (buf00[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(((c5*128) + c9))*(int64)32768)))]*buf01[(((((c7*2) + c11)*16) + c13) + int32((int64(c1)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_inner < 32 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i02_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*32) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_inner < 32 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 8 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 32 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 8) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*32) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 4 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 64 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*64) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_inner < 32 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c1*32) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_inner < 64 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i00 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_inner < 64 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i00 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_outer < 2 | 0
			for 0 <= i02_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i00_inner < 128 | 0
						for 0 <= i03 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*4) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*8) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] = (buf03[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))] + (buf00[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c5*128) + c11))*(int64)32768)))]*buf01[(((c13*16) + c15) + int32((int64(((c1*64) + c7))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i02_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_inner < 64 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i00 < 256 | 0
					for 0 <= i03 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*4) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*8) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 256) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] = (buf03[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))] + (buf00[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c9)*(int64)32768)))]*buf01[(((c11*16) + c13) + int32((int64(((c1*64) + c5))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i03 < 128 | 0
			for 0 <= i02 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((c13 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(c13)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c13) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c13) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c11 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(c11)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c13) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c7*32) + c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c7*64) + c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*32) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c7*32) + c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*64) + c11) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c7*64) + c11))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*2) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c13)*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c13)*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c13)*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i02_outer < 2 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*16) + c11)*4) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*8) + c11)*8) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((((c7*4) + c11)*16) + c13) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i03 < 128 | 0
			for 0 <= i02 < 128 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 4) {
            buf03[((((c7*4) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*4) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c5 + int32((int64(((c7*4) + c9))*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 8) {
            buf03[((((c7*8) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*8) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c5 + int32((int64(((c7*8) + c9))*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 8) {
          unrolled (c9, 0, 16) {
            buf03[((((c7*16) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c7*16) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c5 + int32((int64(((c7*16) + c9))*(int64)128)))]))
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i01_inner < 128 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i01_inner < 64 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i01_inner < 32 | 0
				for 0 <= i03 < 128 | 0
					for 0 <= i02 < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*4) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*4) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*8) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*8) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((((c11*16) + c13) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(c9 + int32((int64(((c11*16) + c13))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 32 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i03_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i03_inner < 64 | 0
						for 0 <= i02 < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*4) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*8) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c13*16) + c15) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i01 < 256 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(c11)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(c13)*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 256) {
              buf03[((((c5*32) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 256) {
              buf03[((((c5*64) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 256) {
              buf03[((((c5*32) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 256) {
              buf03[((((c5*64) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(c11)*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c7*32) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c7*64) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c7*128) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(((c7*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c7*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(((c7*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c7*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(((c7*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c7*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(((c7*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c7*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*32) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(((c7*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c7*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*64) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(((c7*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c7*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*128) + c11))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 8 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 8 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 8 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 8 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 8 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 8 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 4 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 4 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 4 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 4 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 2 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 2 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 2 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 2 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i01_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01_inner < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i01_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01_inner < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_inner < 32 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_inner < 64 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i03_inner < 32 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i03_inner < 64 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00 < 256 | 0
	for 0 <= i03 < 128 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i01 < 256 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          unrolled (c9, 0, 4) {
            buf03[((c5 + int32((int64(((c7*4) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(((c7*4) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*4) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 8) {
            buf03[((c5 + int32((int64(((c7*8) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(((c7*8) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*8) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 256) {
    for (c3, 0, 128) {
      for (c5, 0, 128) {
        for (c7, 0, 16) {
          unrolled (c9, 0, 16) {
            buf03[((c5 + int32((int64(((c7*16) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] = (buf03[((c5 + int32((int64(((c7*16) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))] + (buf00[((c3 + int32((int64(((c7*16) + c9))*(int64)128))) + int32((int64(c1)*(int64)32768)))]*buf01[(c3 + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i03_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i00_inner < 32 | 0
			for 0 <= i03_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*32) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 8 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 32 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 8) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*32) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i03_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i00_inner < 64 | 0
			for 0 <= i03_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*64) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 4 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 64 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*64) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i03_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*64) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*64) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i03_outer < 2 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i03_inner < 64 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*64) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*64) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i00_inner < 128 | 0
			for 0 <= i03_inner < 32 | 0
				for 0 <= i02 < 128 | 0
					for 0 <= i01 < 256 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              unrolled (c13, 0, 4) {
                buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*4) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 8) {
                buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*8) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 16) {
                buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] = (buf03[((c9 + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))] + (buf00[((((c3*32) + c7) + int32((int64(((c11*16) + c13))*(int64)128))) + int32((int64(((c1*128) + c5))*(int64)32768)))]*buf01[(((c3*32) + c7) + int32((int64(c9)*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i00_outer < 2 | 0
	for 0 <= i03_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_inner < 128 | 0
				for 0 <= i03_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i01 < 256 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*4) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*8) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))] + (buf00[((((c3*32) + c9) + int32((int64(((c13*16) + c15))*(int64)128))) + int32((int64(((c1*128) + c7))*(int64)32768)))]*buf01[(((c3*32) + c9) + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i00 < 256 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((((c1*32) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(((c1*32) + c5) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*32) + c7) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*32) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*32) + c7) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 32) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((((c1*32) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(((c1*32) + c5) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*32) + c7) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*32) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*32) + c7) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((((c1*32) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(((c1*32) + c5) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*32) + c7) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 4) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*32) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*32) + c7) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 64) {
        for (c7, 0, 32) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((((c1*64) + c5) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(((c1*64) + c5) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*64) + c7) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*64) + c7) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*64) + c7) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 64) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((((c1*64) + c5) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(((c1*64) + c5) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*64) + c7) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*64) + c7) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*64) + c7) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 64) {
        for (c7, 0, 128) {
          for (c9, 0, 128) {
            for (c11, 0, 256) {
              buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((c9 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((((c1*64) + c5) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(((c1*64) + c5) + int32((int64(c9)*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 256) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*64) + c7) + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 2) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 256) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))] + (buf00[((((c1*64) + c7) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(c13)*(int64)32768)))]*buf01[(((c1*64) + c7) + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 32) {
          for (c9, 0, 32) {
            for (c11, 0, 256) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 32) {
          for (c9, 0, 64) {
            for (c11, 0, 256) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 64) {
          for (c9, 0, 32) {
            for (c11, 0, 256) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 64) {
          for (c9, 0, 64) {
            for (c11, 0, 256) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 128) {
          for (c9, 0, 32) {
            for (c11, 0, 256) {
              buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 64) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 128) {
                buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 128) {
          for (c9, 0, 64) {
            for (c11, 0, 256) {
              buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c7))*(int64)128))) + int32((int64(c11)*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*32) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 64) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*64) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 128) {
                buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((c7*128) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*32) + c11))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*32) + c11))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*32) + c11))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*64) + c11))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*64) + c11))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*64) + c11))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 128) {
              buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*128) + c11))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*128) + c11))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*128) + c11))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*32) + c11))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*32) + c11))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*32) + c11))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*64) + c11))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*64) + c11))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*64) + c11))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 128) {
              buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*128) + c11))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((c7*128) + c11))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*128) + c11))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i00_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 64) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i00_inner < 32 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*4) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*8) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 8) {
          for (c9, 0, 32) {
            for (c11, 0, 2) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*2) + c11)*16) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 8 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 32 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 8) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 2) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*2) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 64 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 4) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*4) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i00_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 4) {
          for (c9, 0, 64) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 4 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i00_inner < 64 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*4) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*8) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 4) {
          for (c9, 0, 32) {
            for (c11, 0, 4) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*4) + c11)*16) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i02_inner < 64 | 0
					for 0 <= i00_inner < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)32768)))] = (buf03[((((c5*64) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 4 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i01_inner < 64 | 0
					for 0 <= i02_inner < 32 | 0
						for 0 <= i00_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 4) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 64) {
            for (c11, 0, 32) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*32) + c11) + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*64) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 8 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i01_inner < 32 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 8) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*32) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01_outer < 2 | 0
		for 0 <= i02_outer < 2 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i01_inner < 128 | 0
					for 0 <= i02_inner < 64 | 0
						for 0 <= i00_inner < 128 | 0
							comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 32) {
                unrolled (c15, 0, 4) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*32) + c13)*4) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 16) {
                unrolled (c15, 0, 8) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*16) + c13)*8) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 2) {
      for (c5, 0, 2) {
        for (c7, 0, 2) {
          for (c9, 0, 128) {
            for (c11, 0, 64) {
              for (c13, 0, 8) {
                unrolled (c15, 0, 16) {
                  buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] = (buf03[((((c5*64) + c11) + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))] + (buf00[((c1 + int32((int64(((c3*128) + c9))*(int64)128))) + int32((int64(((((c7*8) + c13)*16) + c15))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*64) + c11))*(int64)128)))]))
                }
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02_outer < 4 | 0
			for 0 <= i00_outer < 2 | 0
				for 0 <= i02_inner < 32 | 0
					for 0 <= i00_inner < 128 | 0
						comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 32) {
              unrolled (c13, 0, 4) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*32) + c11)*4) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 16) {
              unrolled (c13, 0, 8) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*16) + c11)*8) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 4) {
        for (c7, 0, 2) {
          for (c9, 0, 32) {
            for (c11, 0, 8) {
              unrolled (c13, 0, 16) {
                buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)32768)))] = (buf03[((((c5*32) + c9) + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((((c7*8) + c11)*16) + c13))*(int64)32768)))]*buf01[(c1 + int32((int64(((c5*32) + c9))*(int64)128)))]))
              }
            }
          }
        }
      }
    }
  }
}
for 0 <= i03 < 128 | 0
	for 0 <= i01 < 256 | 0
		for 0 <= i02 < 128 | 0
			for 0 <= i00 < 256 | 0
				comp03

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 64) {
          unrolled (c9, 0, 4) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*4) + c9))*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*4) + c9))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*4) + c9))*(int64)32768)))]*buf01[(c1 + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input01_b1[int32 * 128 * 128]
  allocate _input00_b0[int32 * 128 * 256 * 256]
  allocate _comp03_b2[int32 * 128 * 128 * 256 * 256]
  parallel (c1, 0, 128) {
    for (c3, 0, 256) {
      for (c5, 0, 128) {
        for (c7, 0, 32) {
          unrolled (c9, 0, 8) {
            buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*8) + c9))*(int64)32768)))] = (buf03[((c5 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*8) + c9))*(int64)32768)))] + (buf00[((c1 + int32((int64(c3)*(int64)128))) + int32((int64(((c7*8) + c9))*(int64)32768)))]*buf01[(c1 + int32((int64(c5)*(int64)128)))]))
          }
        }
      }
    }
  }
}
